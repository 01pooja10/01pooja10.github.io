### 50 Random Leetcode Questions

Problems and Solutions with code and explanation.,
### 1. Product Except Self

Create prefix and postfix arrays
[1, 2, 3, 4]
Prefix: [1, 1x2, 1x2x3, 1x2x3x4]
Postfix = [1x2x3x4, 2x3x4, 3x4, 4]
For each entry just multiply entry before it from prefix and entry after it from postfix.
resulting array: [x24, 1x12, 2x4, 6x]

##### Algorithm:
Create two arrays to store the products of preceding and succeeding elements. Then run through both arrays and multiply previous entry from prefix with next entry from postfix to arrive at the current entry for resulting array.

##### Code:
```
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        idx = 0
        pre = []
        post = [1] * len(nums)
        st = nums[0]
        for n in range(len(nums)):
            if n == 0:
                pre.append(st)
            else:
                st = st*nums[n]
                pre.append(st)
        en = nums[-1]
        for n in range(len(nums)-1,-1,-1):
            if n == len(nums)-1:
                post[n] = en
            else:
                #print(en)
                en = en*nums[n]
                post[n] = en
        print(pre,post)
        res = []
        for r in range(len(nums)):
            if r == 0:
                res.append(post[r+1])
            elif r == len(nums)-1:
                res.append(pre[r-1])
            else:
                res.append(pre[r-1]*post[r+1])
        return res
```

### 2. Contains Duplicates

Return true if there are duplicate elements and false if not.
```
if len(set(nums))==len(nums):
	return True
else:
	return False
```
Has time complexity O(N) and set() is a hash table.

### Missing Number

In a list of +ve nos, find the missing number. [0,1,2,4] answer is 3.
`return sum(range(len(nums)+1)) - sum(nums)` - returns the pending value. Solved in O(N) 
Find a list of missing numbers:
```
class Solution:
    def findDisappearedNumbers(self, nums: List[int]) -> List[int]:
        nset = set(nums)
        l = len(nums)+1
        res = []
        for i in range(1,l):
            if i not in nset:
                res.append(i)
        return res
```
### 3. Container with Most H2O



Brute force - compute with left and right pointers - start at 0 and go through every index and right pointer starts at second index and goes up for every index of our left pointer.
```
res = 0
for l in heights:
	for r in range(l+1,len(heights)):
		ar = (r-l) * min(height[l], height[r])
		res = max(res,ar)
return res
```
##### Optimal solution - linear time - O(n)
Assign left pointer and right pointer to extreme elements. Calculate max area and shift the lower value pointer by 1 and calculate again.
Whenever the right height is less than left - you decrease the right by one, else, you increment left by one. 
```
class Solution:
    def maxArea(self, height: List[int]) -> int:
        res = 0
        l, r = 0, len(height)-1
        while l < r:
            #print(l,r)
            ar = (r-l) * min(height[r],height[l])
            res = max(ar,res)
            if height[r]<height[l]:
                r -= 1
            else:
                l += 1
        return res
```
       
### 4. Maximum Product Subarray

If array is: [1,2,3] - all positive numbers = max subarray is the largest possible product of given numbers.
If array is: [-1, -2, -3] = product subarray = 6.
Maintain a max and min subarray to account for signs in the array.
```
class Solution:
    def maxProduct(self, nums: List[int]) -> int:
        ans = max(nums)
        currMin, currMax = 1, 1
        for i in nums:
            tmax = currMax * i
            currMax = max(tmax, i*currMin, i)
            currMin = min(tmax, i*currMin, i)
            ans = max(ans,currMax)
        return ans
```

### 5. Two Sum

With an array: [0,5,2,3,8] and int target = 8, return indices of two numbers summing up to 8 such as (1,3) for 5+3=8.
##### Code:
```
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            find = target-nums[i]
            if find in nums[i+1:]:
                j = nums.index(find,i+1,len(nums))
                return [i,j]
            else:
                continue
            break
```

### 5. Numbers smaller than current number

Find how many numbers in given list [8, 1, 2, 2, 3] are smaller than current number without using two for loops.
1. Use `sorted()` function in Python and get asc. order of list - assign it to temp list.
2. Use a new dict to store index of each entry in the temporary list.
3. Now that index value gives us how many numbers exist before it and hence how many are smaller.
4. Append into a new list: dict[num] for num in nums.

##### Code:
```
class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        temp = sorted(nums)
        d = {}
        for i, n in enumerate(temp):
            if n not in d:
                d[n] = i
        ans = [d[num] for num in nums]
        return ans
```

### 6. Minimum Time Visiting All Points


You have to visit all points in the list on the grid shown and calculate the least possible time taken per path:
 - 1 s for 1 unit vertical
 - 1 s for 1 unit horizontal
 - 1s for sqrt(2) unit diagonal

Basically logic is - gotta move to the next point with as many diagonal movements as possible - that is min(x1,x2 and y1,y2) cuz after that it will be through vertical or horizontal depending on which side is longer. For eg. point [1,1] -> [3,4] you move min([3-1],[4-1])=2 steps diagonally and then move up by the residual distance or steps:
= max([3-1],[4-1]) - min([3-1],[4-1]) 
= 3-2 = 1 
Total time taken = 2 secs +1 sec = 3 secs.
This is basically min([3-1],[4-1]) + max([3-1],[4-1]) - min([3-1],[4-1]) = max([3-1],[4-1])

Then, you sum up all such times for each pair of points.
##### Code
```
class Solution:
    def minTimeToVisitAllPoints(self, points: List[List[int]]) -> int:
        res = 0
        for p in range(0,len(points)-1):
            x1, y1 = points[p]
            x2,y2 = points[p+1]
            dx = abs(x1-x2)
            dy = abs(y1-y2)
            dist = max(dx,dy)
            res += dist
        return res
```

### 7. Spiral Matrix

1. Point is to start the spiral at the top and go inwards depending on the mxn. 
2. My idea was to start appending the first row of every matrix to start with, and pop it. 
3. Now, for the remaining (m-1-last) rows, append the last element of the individual rows and pop the value.
4. Now append the last row in reverse order and pop it.
5. Now the best part is = continue on in a recursive function for the remainder if len of remaining rows m>1 else return the pending row as is.
##### Code:
```
class Solution:
    def spiralOrder(self, matrix: List[List[int]]) -> List[int]:
        spiral = []
        while matrix:
            spiral += matrix.pop(0)
            if matrix and matrix[0]:
                for row in matrix:
                    spiral.append(row.pop(-1))
            if matrix:
                spiral.extend(matrix.pop()[::-1])
            if matrix and matrix[0]:
                for row in matrix[::-1]:
                    spiral.append(row.pop(0))
        return spiral
```
### 8. Number of Islands

Uses breadth first search - traversal through tree nodes goes through each level first instead of depth. Make it iterative.
1. Initialize a count, rows = len(grid), cols = len(grid(0)) and visit = an empty set.
2. Start a nested loop for grid, if index (r,c) = 1 is not in visit, send to the bfs func.
3. For BFS, init a deque and append (r,c) and inside a while q exists loop, popleft() it. For that idx (r,c) - loop through all 4 directions [1,0], [0,1], [-1,0], [0,-1].
4. Check for: r+dir in row range, c+dir in col range, if grid value = 1 and hasn't already been visited.
5. Then append to queue as well as visit.

Time and space complexity: O(mxn)
##### Code - BFS
```
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
        if not grid:
            return 0
        rows,cols = len(grid), len(grid[0])
        visit = set()
        isl = 0
        def bfs(r,c):
            q = deque()
            visit.add((r,c))
            q.append((r,c))
            while q:
                row, col = q.popleft()
                dirs = [[1,0],[-1,0],[0,1],[0,-1]]
                for dr,dc in dirs:
                    r = row + dr
                    c = col + dc
                    if (r in range(rows) and c in range(cols) and 
					                    grid[r][c] == "1" and 
					                    (r,c) not in visit):
                        q.append((r, c))
                        visit.add((r, c))
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == "1" and (r,c) not in visit:
                    bfs(r,c)
                    isl += 1
        return isl
```

##### Code - DFS
```
class Solution:
    def numIslands(self, grid: List[List[str]]) -> int:
                                
        dirs = [[1,0],[0,1],[-1,0],[0,-1]]
        #visited = set()
        rows,cols = len(grid), len(grid[0])
        isl = 0

        def dfs(r,c):
            if (r<0 or c<0 or r>=rows or c>=cols or grid[r][c]=="0"):
                return
            grid[r][c] = "0"
            for dr,dc in dirs:
                dfs(r+dr,c+dc)

        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == "1":
                    dfs(r,c)
                    isl += 1
        return isl
```

### 9. Same Tree?
Basically check if two trees are exactly the same or not - just check for null trees, then value similarity, use recursion for left and right subtrees and you're done.
##### Code
```
class Solution:
    def isSameTree(self, p: Optional[TreeNode], 
							    q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if not p or not q or p.val != q.val:
            return False
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```

### 10. Binary Tree Level Order Traversal

Return a list of lists for each level of tree with node values. Use a queue with FIFO and keep going level by level with insertions into queue at each level and deletions once you're done appending to list.
##### Code:
```
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        q = deque()
        res = []
        q.append(root)
        while q:
            ql = len(q)
            level = []
            for v in range(ql):
                node = q.popleft()
                if node:
                    level.append(node.val)
                    q.append(node.left)
                    q.append(node.right)
            if level:
                res.append(level)
        return res
   ```

### 11. Best Time to Buy and Sell Stock

In a list of stock prices on different days: [7,1,5,4,2,3] - find out the best time to buy a stock and sell it with maximum profit and if none then return zero.

We use the greedy algorithm - use two pointers left and right - iterate through the list index-wise. If right value greater than left, update max variable.
O(n) time and O(1) space complexities.

##### Code
```
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        l, r = 0,1
        maxp = 0
        while r < len(prices):
            if prices[r]>prices[l]:
                diff = prices[r]-prices[l]
                maxp = max(maxp,diff)
            else:
                l = r
            r += 1
        return maxp
```

### 12. Three Sum

Idea is to find triplets that sum up to 0. Returns a list of lists.
1. Sort the original list
2. Run a general for loop
3. Inside it start a left pointer one ahead of current index and a right pointer at the end.
4. Start a while left < right loop.
5. Find sum of current, left and right. If > 0, decrease right and if <0 increase left.
6. Now if sum = 0, append all three values to triplet . ist. Iterate again with left += 1
7. Check if left index lands on same value again if so increment left again.

##### Code
```
class Solution:
    def threeSum(self, nums: List[int]) -> List[List[int]]:
        tripl = []
        nums.sort()
        for idx,num in enumerate(nums):
            if idx>0 and num == nums[idx-1]:
                continue
            left = idx+1
            right = len(nums)-1
            while left<right:
                currSum = num + nums[left] + nums[right]
                if currSum>0:
                    right -= 1
                elif currSum<0:
                    left += 1
                else:
                    tripl.append([nums[left], num, nums[right]])
                    left+=1
                    while (left<right) & (nums[left]== nums[left-1]):
                        left+=1
        return tripl
```

### 13. Longest Mountain  in Array

Given an array [2,1,4,7,3,2,5] find the largest mountain in it and return length -> mountain is: 
```
	   7
   4       3
1              2

Length = 5
```

##### Logic
- Iterate through array from 2nd to last-1 element as peak has to be somewhere in between.
- Find spot where element before and after are less than current element.
- Assign left and right pointers to current element.
- Decrease left, increase right until you find greater values.
- Count length by right-left+1
##### Code
```
class Solution:
    def longestMountain(self, arr: List[int]) -> int:
        mlen = 0

        for i in range(1,len(arr)-1):
            if arr[i-1] < arr[i] > arr[i+1]:
                l = r = i
                while l > 0 and arr[l] > arr[l-1]:
                    l -= 1
                while r < len(arr)-1 and arr[r] > arr[r+1]:
                    r += 1
                mlen = max(mlen, r-l+1)
        return mlen
```

### 14. Contains Duplicate II

Goal is to find duplicate elements in list satisfying index condition abs(j-i) <= some integer k.
If nums = [1,2,3,1] and k=3, return True
If nums = [1,2,3,1,2,3] and k=2, return False
Has an O(N) solution
##### Code:
```
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        seen = set()

        for idx, i in enumerate(nums):
            if i in seen:
                return True
            seen.add(i)
            if len(seen)>k:
                seen.remove(nums[idx-k])
        return False
```

### 15. Minimum Absolute Difference

Point is to find pairs in list whose absolute difference equals least difference possible in the list.
`Input: arr = [4,2,1,3]`
`Output: [[1,2],[2,3],[3,4]]`

- Sort the array.
- Initialize an infinity float variable to compare differences against.
- Run a for loop and find least difference possible.
- In another separate for loop, when diff = min diff, append to pairs list.
##### Code:
```
class Solution:
    def minimumAbsDifference(self, arr: List[int]) -> List[List[int]]:
        arr.sort()
        mad = float('inf')
        pairs = []
        for i in range(len(arr)-1):
            diff = abs(arr[i+1]-arr[i])
            mad = min(mad,diff)
        for i in range(len(arr)-1):
            val = abs(arr[i+1]-arr[i])
            if val==mad:
                pairs.append([arr[i],arr[i+1]])
        return pairs
```

### 16. Minimum Size Subarray Sum

Given an array [2,3,1,2,4,3], and a target value 8, find the lowest sized subarray which satisfies the condition sum(elements in subarray) >= 8. Has O(N) time complexity and O(1) space.

1. Start with initializing left at 0, total at 0 and result (size of subarray) at infinity.
2. In a for loop for right, increment total by first value, start a while total>=target
3. Check min value of result, update total - current left and move left to next.
4. You iterate through the array with a sliding window.
##### Code
```
class Solution:
    def minSubArrayLen(self, target: int, nums: List[int]) -> int:
        total = 0
        l = 0
        result = float("inf")

        for i in range(len(nums)):
            total += nums[i]
            while total>=target:
                result = min(result,i-l+1)
                total -= nums[l]
                l+=1
        if result == float("inf"):
            return 0
        else: return result
```

### 17. Valid Parentheses

1. Find a data structure which pops out most recently added elements - stack (LIFO)
2. Use a dict/hash_map to store the symbols being used to check for closing/opening.
3. If a chr is inside the closed list's keys and has it's open part in dict, pop the stack.
4. Else return false, and if stack isn't empty, return false.

```
class Solution:
    def isValid(self, s: str) -> bool:
        stack = []
        closed = {")":"(","]":"[","}":"{"}

        for ch in s:
            print(ch)
            print(stack)
            if ch in closed:
                if stack and stack[-1]==closed[ch]:
                    stack.pop()
                else:
                    return False
            else:
                stack.append(ch)
        return True if not stack else False
```

### 18. Minimum Value in Rotated Sorted Array

1. Assign an initial result pointing to first element of the array.
2. Then assign left and right pointers l,r to 0th and last index of the array
3. While l<=r -> check if l < r value then update result.
4. then assign a mid value and compare res with mid. If mid > left, then update left to mid+1 else, update right to mid-1.

```
class Solution:
    def findMin(self, nums: List[int]) -> int:
        res = nums[0]
        l,r = 0,len(nums)-1
        while l<=r:
            if nums[l]<nums[r]:
                res = min(res,nums[l])
            m = (l+r)//2
            res = min(res,nums[m])
            if nums[m]>=nums[l]:
                l = m+1
            else:
                r = m-1
        return res
```

### 19. Same Tree


```
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        if p and q and p.val == q.val:
            return self.isSameTree(p.left,q.left) and self.isSameTree(p.right,q.right)
        else:
            return False
```

### 20. Invert Binary Tree


```
class Solution:
    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if not root:
            return None
        
        tmp = root.left
        root.left = root.right
        root.right = tmp
        
        self.invertTree(root.left)
        self.invertTree(root.right)
        return root
```

### 21. Maximum Depth of Binary Tree

```
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        left_d = self.maxDepth(root.left)
		right_d = self.maxDepth(root.right)
        return 1 + max(left_d,right_d)
    
# Solution with iterative DFS   

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [root, 1]
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth + 1])
        return res
```

### 22. Reverse Linked List

```
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev, curr = None, head
        while curr:
            nxt = curr.next
            curr.next = prev
            prev = curr
            curr = nxt
        return prev
```

### 23. Merge 2 Sorted Linked Lists

```
class Solution:
    def mergeTwoLists(self, l1, l2):
        out = ListNode()
        tail = out

        while l1 and l2:
            if l1.val < l2.val:
                tail.next = l1
                l1 = l1.next
            else:
                tail.next = l2
                l2 = l2.next
            tail = tail.next
        
        if l1:
            tail.next = l1
        elif l2:
            tail.next = l2
        return out.next
```

### 24. Linked List Cycle

```
class Solution:
    def hasCycle(self, head: Optional[ListNode]) -> bool:
        visited = set()
        curr = head
        while curr:
            if curr in visited:
                return True
            visited.add(curr)
            curr = curr.next
        return False
```

### 25. Group Anagrams

Anagrams are words that have the same letters jumbled in different ways.
1. Initialize a dict, sort all word alphabetically, use a string to join them = key.
2. Find such similarly occurring words and keep adding to the same dict key.
3. Return the values of the dict.
```
Input: strs = ["act","pots","tops","cat","stop","hat"]

Output: ["hat"],["act", "cat"],["stop", "pots", "tops"]
```

```
def anagram(strs):
    res = defaultdict(list)
    for st in strs:
        sorts = ''.join(sorted(st))
        print(sorts)
        res[sorts].append(st)
    print(res)
    return list(res.values())
```

### 26. Binary Tree Level Order Traversal

1. Initialize a de-queue and append the root of the tree.
2. While q still exists, find length of q and start a for loop for it.
3. Pop the queue and collect the node - if node, append node's value to level list
4. Next, append node's left and right children to queue, continue the loop
5. If level list exists, append it to the tree list and return.

```
class Solution:
    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:
        q = collections.deque()
        q.append(root)
        tree = []
        while q:
            qlen = len(q)
            level = []
            for l in range(qlen):
                node = q.popleft()
                if node:
                    level.append(node.val)
                    q.append(node.left)
                    q.append(node.right)
            if level:
                tree.append(level)
        return tree
```

### 27. Shortest Path in Binary Matrix (BFS)

Given an `n x n` binary matrix `grid`, return _the length of the shortest **clear path** in the matrix_. If there is no clear path, return `-1`.

A **clear path** in a binary matrix is a path from the **top-left** cell (i.e., `(0, 0)`) to the **bottom-right** cell `(n - 1, n - 1)`

1. BFS - initialize a queue, append topmost coordinates (0,0) and length of 1 as ((0,0,1)) to q.
2. Create a visit set to track which positions have been visited already and an 8-dir list
3. While q is true, pop it, assign it to row, col and length. Have a condition to check for - out of bounds and when grid value = 1 to skip
4. Then if row = last and col = last, we have found our result so return the length.
5. Then for other cells, for dr,dc in directions list, if r+dr and c+dc not already in visit, then append to q with length+1 and to visit
6. Return -1 for false cases.

```
class Solution:
    def shortestPathBinaryMatrix(self, grid: List[List[int]]) -> int:
        n = len(grid)
        q = deque([(0,0,1)]) # r, c, length
        visit = set((0,0))
        dirs = [1,0],[0,1],[-1,0],[0,-1],[1,1],[1,-1],[-1,-1],[-1,1]

        while q:
            r,c,l = q.popleft()
            #oob
            #(r,c) in visit is done in main for loop
            if (min(r,c) < 0 or max(r,c)>= n or grid[r][c] == 1):
                continue
            if r == n-1 and c == n-1:
                return l

            for dr,dc in dirs:
                if (r+dr, c+dc) not in visit:
                    q.append((r+dr,c+dc,l+1))
                    visit.add((r+dr,c+dc))
        return -1
```

### 28. Pacific Atlantic Water Flow

1. Start by assigning rows and cols. Get empty visited sets for pacific and atlantic oceans.
2. Define your dfs. Check for (r,c) in visit, out of bounds error, or if current height less than previous height (passed through function) - return nothing
3. Add (r,c) to visited set. Call dfs again for 4 different directions - r +/- 1 and c +/- 1 with normal heights rc as previous height.
4. For c in columns - send in dfs for 0 and rows-1 row
5. For r in rows - send in dfs for 0 and cols-1 column
6. Finally for result, check for r in row and for c in col, if (r,c) in both pac and atl sets.

```
class Solution:
    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:
        rows,cols = len(heights),len(heights[0])
        pac, atl = set(), set()

        def dfs(r,c,visit,prev_ht):
            if ((r,c) in visit or r<0 or c<0 or r==rows or c==cols 
            or heights[r][c]<prev_ht):
                return
            visit.add((r,c))
            
            dfs(r+1,c,visit,heights[r][c])
            dfs(r-1,c,visit,heights[r][c])
            dfs(r,c+1,visit,heights[r][c])
            dfs(r,c-1,visit,heights[r][c])

        for c in range(cols):
            dfs(0, c, pac, heights[0][c])
            dfs(rows-1,c, atl, heights[rows-1][c])
        
        for r in range(rows):
            dfs(r, 0, pac, heights[r][0])
            dfs(r, cols-1, atl, heights[r][cols-1])
        
        result = []
        for r in range(rows):
            for c in range(cols):
                if (r,c) in pac and (r,c) in atl:
                    result.append([r,c])
        return result
```

### 29. Longest Consecutive Sequence

**Input:** nums = `[100,4,200,1,3,2]`
**Output:** 4
**Explanation:** The longest consecutive elements sequence is `[1, 2, 3, 4]`. Therefore its length is 4.

1. Initialize set of nums and a longest count variable
2. Iterate through nums, set a streak and current var to 0 and current number
3. While curr in set of nums, update streak and add 1 to current number to see if there is a consecutive increase.
4. Find max between longest and streak.

```
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        numSet = set(nums)
        longest = 0
        for n in numSet:
            if (n-1) not in numSet:
                length = 1
                while(n+length) in numSet:
                    length += 1
                longest = max(length,longest)
        return longest
```

### 30. Search in Rotated Sorted Array

1. First find the pivot element - while l < r, get mid and increase L to m+1 if mid > l else put r=m
2. Now in a binary search function, while l<=r find m, check for target, if less - increase l to m+1 and if more, decrease r to m-1.
3. Now for results, call above function with l=0 and r=pivot-1 and if not -1, return it. Then return a function-call of second half of the elements (pivot, nums-1).

```
class Solution:
	def search(nums,target):
		l, r = 0, len(nums)-1
		
		while l<r:
			m = (l+r)//2
			if nums[m]>nums[r]:
				l = m+1
			else:
				r = m
		pivot = l
		def bsr(l,r):
			while l<=r:
				m = (l+r)//2
				if nums[m]==target:
					return m
				elif nums[m]<target:
					l = m+1
				else:
					r = m-1
			return -1
		result = bsr(0,pivot-1)
		if result != -1:
			return result
		return bsr(pivot, len(nums)-1)	
```

### 31. Top K Most Frequent Elements

1. Initialize a count defaultdict() and through for loop, append count of each number present.
2. In another array, append (count,num) as a list and sort it. Create a new results list.
3. While len(results) is less than given integer k, pop from array and append the value to results.

```
class Solution:
    def topKFrequent(self, nums: List[int], k: int) -> List[int]:
        count = defaultdict()
        for num in nums:
            count[num] = 1 + count.get(num,0)
        arr = []
        for n,c in count.items():
            arr.append([c,n])
        arr.sort()
        res = []
        while len(res)<k:
            res.append(arr.pop()[-1])
        return res
```

### 32. Count Sub Islands

```
class Solution:
    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:
        rows,cols = len(grid1),len(grid1[0])
        visit = set()
        count = 0

        def dfs(r,c):
            if (r<0 or c<0 or r>=rows or c>=cols or 
	            grid2[r][c]==0 or 
	            (r,c) in visit):
                return True
                
            if grid1[r][c] == 0:
                return False
                
            visit.add((r,c))

            return dfs(r-1,c) & dfs(r+1,c) & dfs(r,c-1) & dfs(r,c+1)

        for r in range(rows):
            for c in range(cols):
                if (grid2[r][c] == 1 and (r,c) not in visit and dfs(r,c)):
                    count += 1
                    print(count)
        return count
```

### 33. Rotate Image


```
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        """
        Do not return anything, modify matrix in-place instead.
        """
        l,r = 0, len(matrix)-1
        while l<r:
            #0 -> len(matrix) iters
            #Use loop for inner matrix spots
            for i in range(r-l):
                top,bottom = l,r
                #save topleft
                topLeft = matrix[top][l+i]

                #move bottom left to topl
                matrix[top][l+i] = matrix[bottom-i][l]

                #move bot right to bot left
                matrix[bottom-i][l] = matrix[bottom][r-i]

                #move top right to bot right
                matrix[bottom][r-i] = matrix[top+i][r]

                #move top left to top right
                matrix[top+i][r] = topLeft
            r -= 1
            l += 1
```


### 34. Climbing Stairs

```
class Solution:
    def climbStairs(self, n: int) -> int:
        if n<=2:
            return n
        dp = [0]*(n+1)
        dp[0] = 0
        dp[1] = 1
        dp[2] = 2
        for i in range(3,n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
```


### 35. Set Matrix Zeroes


1. Find num rows and cols of matrix, create vectors of False rows and columns of same size
2. If matrix entry is 0, set row and column vector entries to True for corresponding row and col.
3. Inside matrix now alter each row and col according to row and col vector values if set to True.

```
class Solution:
    def setZeroes(self, matrix: List[List[int]]) -> None:
    
	    rows,cols = len(matrix),len(matrix[0])
	    row,col = [False]*rows,[False]*cols
	    
	    for r in range(rows):
		    for c in range(cols):
			    if matrix[r][c]==0:
				    row[r] = True
				    col[c] = True
				    
		for r in range(rows):
			for c in range(cols):
				if row[r] and col[c]:
					matrix[r][c] = 0
					
		return matrix
```

### 36. Maximum Subarray

1. Initialize a max subarray = first element of array
2. Your current sum will be 0 and for every num in array, check if current sum is < 0 - yes - set it back to 0.
3. Then increment current sum by number. And calculate max subarray again.

```
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        maxSub = nums[0]
        cSum = 0
        for n in nums:
            if cSum < 0:
                cSum = 0
            cSum += n
            maxSub = max(maxSub, cSum)
        return maxSub
```

### 37. Evaluate Reverse Polish Notation

```
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        
        for t in tokens:
            
            if t not in "+-*/":
                stack.append(int(t))
              
            else:
              
                r, l = stack.pop(), stack.pop()
                if t == "+":
                    stack.append(l+r)
                elif t == "-":
                    stack.append(l-r)
                elif t == "*":
                    stack.append(r*l)
                else:
                    stack.append(int(float(l)/r))
            
        return stack.pop()
```

### 38. Min Depth of Binary Tree

```
class Solution:
    def minDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        if None in [root.left, root.right]:
            return max(self.minDepth(root.left),self.minDepth(root.right)) + 1
        else:
            return min(self.minDepth(root.left),self.minDepth(root.right)) + 1
```

### 39. K Closest Points to Origin

Uses a heap (minheap so negate distances for max) - use heappush to add elements if len(heap) < k.

```
class Solution:
    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:
        heap = []
        for (x,y) in points:
            dist = -(x**2 + y**2)
            if len(heap) == k:
                heapq.heappushpop(heap, (dist,x,y))
            else:
                heapq.heappush(heap, (dist,x,y))
        return [(x,y) for (dist,x,y) in heap]
```

### 40. Clone Graph (BFS)

1. Use a dict called clones to map og nodes to their deepcopy. Also maintain same neighbors
2. While q, pop it, get current node. Create a current cloned node using clones dict with curr.val
3. For neighbor in current node's neighbors, in the loop, if neighbor.val isn't already in clones dict, then set clones(neighbor.val) = a new Node(neighbor.val)
4. Append neighbor to q as well
5. Set current clone's neighbor also append clones(neighbor.val)
6. Return the clones(node.val)

```
class Solution:
    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:
        if not node:
            return node
        q = deque([node])
        clones = {node.val:Node(node.val)}

        while q:
            curr = q.popleft()
            curr_clone = clones[curr.val]
            for nei in curr.neighbors:
                if nei.val not in clones:
                    clones[nei.val] = Node(nei.val)
                    q.append(nei)
                curr_clone.neighbors.append(clones[nei.val])
        return clones[node.val]
```

### 41. Course Schedule (DFS)

1. Create an adjacency list - with courses as keys and prereqs as values.
2. Run iterative DFS - look for any cycles or circular dependencies - courses can't be taken.
3. Create a stack with (course, set()) and **while stack** : current_course, visited will pop off the stack.
4. If the curr course is in the set of visited: return False - it indicates a cycle.
5. Outside the above if, add the current_course to visited.
6. For every prereq in the adj(course) dict, append prereq to the stack along with a copy of the visited set.
7. Outside the **while** set adjacency(course) to an empty list - remove the course from checking.
8. Return True yay!

```
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:
        adj = {course:[] for course in range(numCourses)}
        for c,pre in prerequisites:
            adj[c].append(pre)
        for course in range(numCourses):
            stack = [(course, set())] #course and visited or not?
            while stack:
                curr, visited = stack.pop()
                if curr in visited:
                    return False
                visited.add(curr)
                for pre in adj[curr]:
                    stack.append((pre,visited.copy()))
            adj[course] = []
        return True
```

### 42. Time needed to buy tickets

I SOLVED IT MYSELFFFF HEHEHEHEHEHEH <3

```
class Solution:
    def timeRequiredToBuy(self, tickets: List[int], k: int) -> int:
        q = deque()
        for i,tix in enumerate(tickets):
            q.append([i,tix])
        #print(q)
        time = 0
        while q: # starting the process
            idx, curr_tix = q.popleft() #
            #print(curr_tix)
            time += 1
            updated = curr_tix-1
            if idx == k:
                if updated == 0:
                    return time
            if updated > 0:
                q.append([idx,updated])
```

### 43. Number of laser beams in a bank

1. Count beams (1s) in the first row and initialize it as the previous count of beams.
2. Set result to 0 for counting later. Run a loop through the remaining rows, count 1s
3. If 1s exist, update result = result + previ ous_count * current_count
4. Then set previous to current and return the result.

```
class Solution:
    def numberOfBeams(self, bank: List[str]) -> int:
        prev = bank[0].count("1")
        result = 0
        for row in range(1,len(bank)):
            curr = bank[row].count("1")
            if curr:
                result += prev * curr
                prev = curr
        return result
```

### 44. Longest Palindromic Substring

1. Initialize result string and length variable. 
2. Inside a for loop through s, assign left and right pointers at every character and iterate with while loop.
3. While l>0 and r<len(s), and if string of l == string of r - baaaab (b=b), keep going backward
```
class Solution:
    def longestPalindrome(self, s: str) -> str:
        res = ""
        resLen = 0
        for i in range(len(s)):
            # odd
            l,r = i,i
            while l>=0 and r<len(s) and s[l] == s[r]:
                if (r-l+1) > resLen:
                    res = s[l:r+1]
                    resLen = r-l+1
                l -= 1
                r += 1
            # even
            l,r = i,i+1
            while l>=0 and r<len(s) and s[l] == s[r]:
                if (r-l+1) > resLen:
                    res = s[l:r+1]
                    resLen = r-l+1
                l -= 1
                r += 1
        return res
```

### 45. Two Sum II 

```
class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        l, r = 0, len(numbers)-1
        tsum = 0
        while l<r:
      
            tsum = numbers[l] + numbers[r]
            
            if tsum > target:
                r -= 1

            elif tsum < target:
                l += 1
             
            else:
                return [l+1, r+1]
        return
```

### 46. Koko Eating Bananas (Binary Search)

1. Through the piles array, do a **binary search**, for how many bananas per hour she can eat
2. Set L = 1 and R = max(piles). While l<=r, let k be the mid and hrs = 0
3. For every value in piles list, add the ceil(pile value / k) to hrs.
4. If hrs < = h -> update r to k-1 and search the smaller array
5. Else, update l to k+1

```
class Solution:
    def minEatingSpeed(self, piles: List[int], h: int) -> int:
        l,r = 1,max(piles)
        res = r
        while l<=r:
            k = (l+r)//2
            hrs = 0
            for p in piles:
                hrs += ceil(p/k)
            if hrs <= h:
                res = min(res,k)
                r = k-1
            else:
                l = k+1
        return res
```

### 47. Rotting Oranges (BFS)

1. Do a BFS cuz you need breadth to start with multiple rotten narangas
2. Init a deque(). Create time and fresh variables - maintain a directions list.
3. In a nested for (r,c) - check for fresh oranges, add rotten oranges to q.
4. Start a while loop monitoring q and fresh>0
5. Another for loop for each rotten orange in q (q len)
6. Pop the q - get r and c. In a dirs for loop, add (dr and dc) to (r and c)
7. Check for out of bounds condition and if grid!=1 (grid doesn't have an orange)
8. Outside it, set the grid value to 2 meaning "rotten"
9. Decrease number of fresh oranges.
10. Append (r,c) to q
11. Outside the for loop, increase time by 1
12. If fresh is now 0, return time else -1.

```
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        q = deque()
        time,fresh = 0, 0
        dirs = [[0,1],[1,0],[0,-1],[-1,0]]
        rows,cols = len(grid),len(grid[0])
        for r in range(rows):
            for c in range(cols):
                if grid[r][c]==1:
                    fresh+=1
                if grid[r][c]==2:
                    q.append((r,c))
        while q and fresh>0:
            for i in range(len(q)):
                r,c = q.popleft()
                for dr,dc in dirs:
                    row = r+dr
                    col = c+dc
                    if (row<0 or col<0 or row>=rows 
	                    or col>=cols or 
			            grid[row][col]!=1):
                        continue
                    grid[row][col] = 2
                    fresh -= 1
                    q.append((row,col))
            time += 1
        if fresh==0:
            return time
        else:
            return -1
```

### 48. Longest Substring Without Repeating Characters

```
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        l = 0
        ret = 0
        chrset = set()
        for r in range(len(s)):
            while s[r] in chrset:
                chrset.remove(s[l])
                l += 1
            chrset.add(s[r])
            ret = max(ret, r-l+1)
        return ret
```

### 49. Word Search


```
class Solution:
    def exist(self, board: List[List[str]], word: str) -> bool:
        rows,cols = len(board),len(board[0])
        visit = set()

        def dfs(r,c,i):
            if i == len(word):
                return True
            if (r<0 or c<0 or r>=rows or c>=cols or board[r][c]!=word[i] or (r,c) in visit):
                return False

            visit.add((r,c))
            result = (dfs(r+1,c,i+1) or
                      dfs(r-1,c,i+1) or
                      dfs(r,c+1,i+1) or
                      dfs(r,c-1,i+1))
            visit.remove((r,c))
            return result

            
        
        for r in range(rows):
            for c in range(cols):
                if dfs(r,c,0):
                    return True
        return False
```

### 50. Search Insert Position

```
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        l,r = 0,len(nums)-1
        while l<=r:
            m = (l+r)//2
            if nums[m]>target:
                r -= 1
            elif nums[m]<target:
                l+=1
            else:
                return m
        return l
```

### 51. Minimize Maximum of Array


1. You have to return the minimum possible value of the maximum element in the array by doing any of the following operations:
	1. Decrement value from current max element, add to previous (note: 1st element of nums doesn't change cuz no value to its left so result starts there.)
	2. Increment previous value without crossing the maximum possible value (5 in our case)
2. How to determine max possible value? Get the average of all nums and its ceiling.
3. Return the maximum between result and the average.

```
class Solution:
    def minimizeArrayValue(self, nums: List[int]) -> int:
        result = nums[0]
        tot = nums[0]
        for n in range(1,len(nums)):
            tot += nums[n]
            result = max(result, ceil(tot/(n+1)))
        return result
```

### 52. Removing Stars in String

```
class Solution:
    def removeStars(self, s: str) -> str:
        stack = []
        for ch in s:
            if ch!="*":
                stack.append(ch)
            if ch == "*":
                stack.pop()
        out = "".join(stack)
        return out
```

### 53. Successful Pairs of Spells and Potions



```
class Solution:
    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -> List[int]:
        #spells.sort()
        potions.sort()
        pairs = []
        
        for i in range(len(spells)):
            #count = 0
            #p = 0
            l,r = 0, len(potions)-1

            while l<=r:
                m = (l+r)//2
                if spells[i]*potions[m] >= success:
                    r = m-1
                else:
                    l = m+1
            pairs.append(len(potions)-l)
        return pairs
```

### 54. Number of Closed Islands

```
class Solution:
    def closedIsland(self, grid: List[List[int]]) -> int:
        rows,cols = len(grid),len(grid[0])
        visit = set()
        islands = 0

        def dfs(r,c):
            if (r<0 or c<0 or r>=rows or c>=cols):
                return 0
            if (grid[r][c]==1 or (r,c) in visit):
                return 1
            visit.add((r,c))

            return min(dfs(r+1,c),
                dfs(r-1,c),
                dfs(r,c+1),
                dfs(r,c-1))

        
        for r in range(rows):
            for c in range(cols):
                if grid[r][c] == 0 and (r,c) not in visit:
                    islands += dfs(r,c)
        return islands
```

### 55. Optimal Partition of String



```
class Solution:
    def partitionString(self, s: str) -> int:
        curr = set()
        res = 1
        for ch in s:
            if ch in curr:
                res+=1
                curr = set()
            curr.add(ch)
        return res
```

